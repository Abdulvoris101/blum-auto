import datetimefrom typing import Listfrom aiogram.exceptions import TelegramNotFoundfrom sqlalchemy import select, existsfrom sqlalchemy.orm import sessionfrom apps.accounts.models import Accountfrom apps.common.exceptions import AiogramExceptionfrom apps.common.settings import settingsfrom apps.core.models import Userfrom apps.payment.models import AccountSubscription, UserPaymentfrom apps.payment.scheme import AccountSubscriptionScheme, AccountSubscriptionCreateSchemefrom bot import bot, logger, i18nfrom db.setup import AsyncSessionLocalfrom utils import textfrom utils.events import sendToUserclass SubscriptionManager:    @classmethod    async def isExistsByAccountId(cls, accountId: int) -> bool:        async with AsyncSessionLocal() as session:            result = await session.execute(select(exists().where(AccountSubscription.accountId == accountId)))            return result.scalar()    @classmethod    async def isExistsBySubscriptionId(cls, subscriptionId: int) -> bool:        async with AsyncSessionLocal() as session:            result = await session.execute(select(exists().where(AccountSubscription.id == subscriptionId)))            return result.scalar()    @classmethod    async def updateSubscription(cls, accountId: int):        if not await cls.isExistsByAccountId(accountId):            return        currentPeriodEnd = datetime.datetime.now() + datetime.timedelta(days=30)        subscription = await AccountSubscription.getByAccountId(accountId)        subscription.currentPeriodEnd = currentPeriodEnd        subscription.currentPeriodStart = datetime.datetime.now()        subscription.isPaid = True        subscription.isCanceled = False        subscription.canceledAt = None        subscription.isFreeTrial = False        await subscription.save()    @classmethod    async def subscribe(cls, telegramId: int, accountId: int, isFreeTrial: bool):        if await cls.isExistsByAccountId(accountId):            return        freeTrialEndDate = datetime.datetime.now() + datetime.timedelta(days=3)        monthlyEndDate = datetime.datetime.now() + datetime.timedelta(days=30)        currentPeriodEnd = freeTrialEndDate if isFreeTrial else monthlyEndDate        scheme = AccountSubscriptionCreateScheme(accountId=accountId, telegramId=telegramId,                                                 isFreeTrial=isFreeTrial, currentPeriodEnd=currentPeriodEnd,                                                 canceledAt=None)        subscription = AccountSubscription(**scheme.model_dump())        await subscription.save()    @classmethod    async def isAccountSubscriptionActive(cls, accountId: int) -> bool:        subscription = await AccountSubscription.getByAccountId(accountId)        if not subscription:            return False        if subscription.isCanceled or not subscription.isPaid:            return False        return True    @classmethod    async def isAccountSubscriptionActiveOrPremium(cls, accountId: int) -> bool:        subscription = await AccountSubscription.getByAccountId(accountId)        if not subscription:            return False        if subscription.isFreeTrial:            return False        if subscription.isCanceled or not subscription.isPaid:            return False        return True    @classmethod    async def updateCanceledSubscriptions(cls, telegramId: int):        async with AsyncSessionLocal() as session:            result = await session.execute(                select(AccountSubscription).filter(                    AccountSubscription.isPaid == False,                    AccountSubscription.isCanceled == True,                    AccountSubscription.telegramId == telegramId                )            )            subscriptions = result.scalars().all()            for subscription in subscriptions:                account = await Account.get(subscription.accountId)                userPayment = await UserPayment.get(subscription.telegramId)                if userPayment.balance >= settings.PRICE:                    subscription.currentPeriodStart = datetime.datetime.now()                    subscription.currentPeriodEnd = datetime.datetime.now() + datetime.timedelta(days=30)                    subscription.isCanceled = False                    subscription.isPaid = True                    subscription.canceledAt = None                    userPayment.balance -= settings.PRICE                    session.add(userPayment)                    await sendToUser(subscription.telegramId, text.SUBSCRIPTION_UPDATED_SCHEDULE.format(                        sessionName=account.sessionName))            await session.commit()    @classmethod    async def cancelOrUpdateSubscriptions(cls):        async with AsyncSessionLocal() as session:            result = await session.execute(                select(AccountSubscription).filter(                    AccountSubscription.isPaid == True,                    AccountSubscription.isCanceled == False,                    datetime.datetime.now() > AccountSubscription.currentPeriodEnd                )            )            subscriptions = result.scalars().all()            for subscription in subscriptions:                account = await Account.get(subscription.accountId)                userPayment = await UserPayment.get(subscription.telegramId)                user = await User.get(subscription.telegramId)                i18n.ctx_locale.set(user.languageCode)                if userPayment.balance >= settings.PRICE:                    subscription.currentPeriodStart = datetime.datetime.now()                    subscription.currentPeriodEnd = datetime.datetime.now() + datetime.timedelta(days=30)                    subscription.isCanceled = False                    subscription.isPaid = True                    userPayment.balance -= settings.PRICE                    session.add(userPayment)                    await session.commit()                    with i18n.context():                        await sendToUser(subscription.telegramId, text.SUBSCRIPTION_UPDATED_SCHEDULE.format(                            sessionName=account.sessionName))                else:                    subscription.isCanceled = True                    subscription.isPaid = False                    subscription.canceledAt = datetime.datetime.now()                    try:                        with i18n.context():                            await sendToUser(subscription.telegramId, text.SUBSCRIPTION_END.format(                                sessionName=account.sessionName, needAmount=settings.PRICE))                    except TelegramNotFound as e:                        logger.error("User not found", e)                session.add(subscription)                await session.commit()            await session.commit()