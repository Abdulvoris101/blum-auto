import datetimefrom typing import Listfrom aiogram.exceptions import TelegramNotFoundfrom sqlalchemy import select, existsfrom sqlalchemy.orm import sessionfrom apps.accounts.models import Accountfrom apps.common.settings import settingsfrom apps.payment.models import AccountSubscription, UserPaymentfrom apps.payment.scheme import AccountSubscriptionScheme, AccountSubscriptionCreateSchemefrom bot import bot, loggerfrom db.setup import AsyncSessionLocalfrom utils import textclass SubscriptionManager:    @classmethod    async def isExistsByAccountId(cls, accountId: int) -> bool:        async with AsyncSessionLocal() as session:            result = await session.execute(select(exists().where(AccountSubscription.accountId == accountId)))            return result.scalar()    @classmethod    async def isExistsBySubscriptionId(cls, subscriptionId: int) -> bool:        async with AsyncSessionLocal() as session:            result = await session.execute(select(exists().where(AccountSubscription.id == subscriptionId)))            return result.scalar()    @classmethod    async def subscribe(cls, telegramId: int, accountId: int, isFreeTrial: bool):        if await cls.isExistsByAccountId(accountId):            return        freeTrialEndDate = datetime.datetime.now() + datetime.timedelta(days=3)        monthlyEndDate = datetime.datetime.now() + datetime.timedelta(days=30)        currentPeriodEnd = freeTrialEndDate if isFreeTrial else monthlyEndDate        scheme = AccountSubscriptionCreateScheme(accountId=accountId, telegramId=telegramId,                                                 isFreeTrial=isFreeTrial, currentPeriodEnd=currentPeriodEnd,                                                 canceledAt=None)        subscription = AccountSubscription(**scheme.model_dump())        await subscription.save()    @classmethod    async def isAccountSubscriptionActive(cls, accountId: int) -> bool:        subscription = await AccountSubscription.getByAccountId(accountId)        if not subscription:            return False        if subscription.isCanceled or not subscription.isPaid:            return False        return True    @classmethod    async def updateCanceledSubscriptions(cls, telegramId: int):        async with AsyncSessionLocal() as session:            result = await session.execute(                select(AccountSubscription).filter(                    AccountSubscription.isPaid == False,                    AccountSubscription.isCanceled == True,                    AccountSubscription.telegramId == telegramId                )            )            subscriptions = result.scalars().all()            for subscription in subscriptions:                account = await Account.get(subscription.accountId)                userPayment = await UserPayment.get(subscription.telegramId)                if userPayment.balance >= settings.PRICE:                    subscription.currentPeriodStart = datetime.datetime.now()                    subscription.currentPeriodEnd = datetime.datetime.now() + datetime.timedelta(days=30)                    subscription.isCanceled = False                    subscription.isPaid = True                    subscription.canceledAt = None                    userPayment.balance -= settings.PRICE                    await userPayment.save()                    await bot.send_message(subscription.telegramId, text.SUBSCRIPTION_UPDATED.format(                        sessionName=account.sessionName))            await session.commit()    @classmethod    async def cancelOrUpdateSubscriptions(cls):        async with AsyncSessionLocal() as session:            result = await session.execute(                select(AccountSubscription).filter(                    AccountSubscription.isPaid == True,                    AccountSubscription.isCanceled == False,                    AccountSubscription.currentPeriodEnd > datetime.datetime.now()                )            )            subscriptions = result.scalars().all()            for subscription in subscriptions:                account = await Account.get(subscription.accountId)                userPayment = await UserPayment.get(subscription.telegramId)                if userPayment.balance >= settings.PRICE:                    subscription.currentPeriodStart = datetime.datetime.now()                    subscription.currentPeriodEnd = datetime.datetime.now() + datetime.timedelta(days=30)                    subscription.isCanceled = False                    subscription.isPaid = True                    userPayment.balance -= settings.PRICE                    await userPayment.save()                    await bot.send_message(subscription.telegramId, text.SUBSCRIPTION_UPDATED.format(                        sessionName=account.sessionName))                else:                    subscription.isCanceled = True                    subscription.isPaid = False                    subscription.canceledAt = datetime.datetime.now()                    try:                        await bot.send_message(subscription.telegramId, text.SUBSCRIPTION_END.format(                            sessionName=account.sessionName, needAmount=settings.PRICE))                    except TelegramNotFound as e:                        logger.error("User not found", e)                await subscription.save()            await session.commit()