from unipayment import UniPaymentClient, CreateInvoiceRequest, CreateInvoiceResponse, ApiExceptionfrom apps.common.exceptions import InvalidRequestExceptionfrom apps.common.settings import settingsfrom apps.core.managers import UserManagerfrom apps.core.models import Userfrom apps.payment.managers import SubscriptionManagerfrom apps.payment.models import Order, UserPaymentfrom bot import i18nfrom utils import textfrom utils.events import sendToUser, sendErrorclient = UniPaymentClient(settings.CLIENT_ID,settings.CLIENT_SECRET)def createInvoice(orderId: int, amount: float, lang: str) -> CreateInvoiceResponse:    notifyUrl = settings.WEB_URL + '/payment-webhook'    request = CreateInvoiceRequest(price_amount=amount, price_currency='USD', notify_url=notifyUrl, order_id=orderId,                                   title="Blum Auto", description="Top up the blum auto balance",                                   app_id=settings.APP_ID, lang=lang)    response = client.create_invoice(request)    if response.code == "OK":        return response    raise InvalidRequestException(messageText=text.PAYMENT_ERROR.value,                                  exceptionText="Null")class PaymentProcessor:    def __init__(self, data):        self.data = data    async def handle(self):        try:            data = self.data            check_ipn_response = client.check_ipn(data)            if check_ipn_response.code != 'OK':                return            order = await self.updateOrder()            status = data['status']            if status == 'Confirmed':                user = await User.get(order.telegramId)                userPayment = await UserPayment.get(order.telegramId)                userPayment.balance += order.paidAmount                await userPayment.save()                i18n.ctx_locale.set(user.languageCode)                with i18n.context():                    await sendToUser(order.telegramId, text=text.SUCCESSFULLY_PAYED.format(                        amount=order.paidAmount))                    await SubscriptionManager.updateCanceledSubscriptions(telegramId=user.telegramId)                if await UserManager.isActiveReferral(user.referredBy, order.telegramId):                    await self.handleReferralBonus(user)        except (ApiException, ValueError, AttributeError) as e:            with i18n.context():                await sendError(text.ORDER_ERROR_TEMPLATE.format(orderId=None, message=str(e.body)))    async def updateOrder(self) -> Order:        data = self.data        orderId = data.get("order_id")        order = await Order.get(int(orderId))        if not order:            raise ValueError(f"Order with ID {orderId} not found")        order.status = data.get("status")        order.network = data.get("network")        order.cryptoCurrency = data.get("pay_currency")        order.errorStatus = data.get("error_status")        order.paidCryptoAmount = data.get("paid_amount")        order.exchangeRate = data.get("exchange_rate")        order.paidAmount = round(order.paidCryptoAmount * order.exchangeRate, 2)        order.invoiceId = data.get("invoice_id")        await order.save()        return order    async def handleReferralBonus(self, user: User):        referral_user = await User.get(int(user.referredBy))        ref_user_payment = await UserPayment.getByUserId(referral_user.id)        await UserManager.addUserToReferrals(user.referredBy, user.telegramId)        ref_user_payment.balance += settings.REFERRAL_PRICE        await ref_user_payment.save()        i18n.ctx_locale.set(referral_user.languageCode)        with i18n.context():            await sendToUser(referral_user.telegramId, text.CONGRATS_GAVE_REQUESTS.format(                referralPrice=settings.REFERRAL_PRICE))