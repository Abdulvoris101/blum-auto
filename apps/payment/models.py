from sqlalchemy import Column, JSON, Integer, desc, String, Enum, Boolean, Float, BigInteger, DateTime, selectfrom sqlalchemy.orm import class_mapperfrom apps.common.exceptions import NullPointerExceptionfrom db.setup import Base, AsyncSessionLocalclass UserPayment(Base):    __tablename__ = 'user_payment'    id = Column(Integer, primary_key=True, autoincrement=True)    telegramId = Column(BigInteger, unique=True)    userId = Column(BigInteger, unique=True)    balance = Column(Float)    trialBalance = Column(Float)    stars = Column(Integer, nullable=True, default=0)    createdAt = Column(DateTime, nullable=True)    def __init__(self, telegramId, userId, balance, trialBalance, stars, createdAt):        self.telegramId = telegramId        self.userId = userId        self.balance = balance        self.trialBalance = trialBalance        self.stars = stars        self.createdAt = createdAt        super().__init__()    async def save(self):        async with AsyncSessionLocal() as session:            session.add(self)            await session.commit()        return self    @classmethod    async def get(cls, telegramId):        async with AsyncSessionLocal() as session:            userPayment = await session.execute(select(UserPayment).filter(UserPayment.telegramId == telegramId))            userPayment = userPayment.scalar_one_or_none()            return userPayment    @classmethod    async def getByUserId(cls, userId):        async with AsyncSessionLocal() as session:            user = await session.execute(select(UserPayment).filter(UserPayment.userId == userId))            user = user.scalar_one_or_none()            return user    @classmethod    async def update(cls, instance, column, value):        async with AsyncSessionLocal() as session:            setattr(instance, column, value)            await session.commit()    @classmethod    async def delete(cls, telegramId):        async with AsyncSessionLocal() as session:            user = await session.execute(select(UserPayment).filter(UserPayment.telegramId == telegramId))            user = user.scalar_one_or_none()            if user:                session.delete(user)                await session.commit()    def to_dict(self):        """Converts SQL Alchemy model instance to dictionary."""        return {c.key: getattr(self, c.key) for c in class_mapper(self.__class__).mapped_table.c}class Order(Base):    __tablename__ = 'order'    id = Column(Integer, primary_key=True)    telegramId = Column(BigInteger)    userPaymentId = Column(Integer)    invoiceId = Column(String, nullable=True)    amount = Column(Float)    paidCryptoAmount = Column(Float)    paidAmount = Column(Float)    cryptoCurrency = Column(String, nullable=True)    status = Column(String)    errorStatus = Column(String, nullable=True)    network = Column(String, nullable=True)    exchangeRate = Column(Float, nullable=True)    expirationTime = Column(DateTime, nullable=True)    createdAt = Column(DateTime, nullable=True)    def __init__(self, telegramId, userPaymentId, amount, paidAmount, paidCryptoAmount, status, exchangeRate,                 createdAt):        self.telegramId = telegramId        self.userPaymentId = userPaymentId        self.amount = amount        self.status = status        self.paidAmount = paidAmount        self.paidCryptoAmount = paidCryptoAmount        self.exchangeRate = exchangeRate        self.createdAt = createdAt        super().__init__()    async def save(self):        async with AsyncSessionLocal() as session:            session.add(self)            await session.commit()        return self    @classmethod    async def get(cls, orderId):        async with AsyncSessionLocal() as session:            order = await session.execute(select(Order).filter(Order.id == orderId))            order = order.scalar_one_or_none()            return order    @classmethod    async def update(cls, instance, column, value):        async with AsyncSessionLocal() as session:            setattr(instance, column, value)            await session.commit()    @classmethod    async def delete(cls, orderId):        async with AsyncSessionLocal() as session:            order = await session.execute(select(Order).filter(Order.id == orderId))            order = order.scalar_one_or_none()            if order:                session.delete(order)                await session.commit()    def to_dict(self):        """Converts SQL Alchemy model instance to dictionary."""        return {c.key: getattr(self, c.key) for c in class_mapper(self.__class__).mapped_table.c}class AccountSubscription(Base):    __tablename__ = 'account_subscription'    id = Column(BigInteger, primary_key=True)    telegramId = Column(BigInteger)    accountId = Column(BigInteger)    isPaid = Column(Boolean, default=False)    isFreeTrial = Column(Boolean, default=False)    isCanceled = Column(Boolean, default=False)    canceledAt = Column(DateTime, nullable=True)    currentPeriodStart = Column(DateTime)    currentPeriodEnd = Column(DateTime, nullable=True)    def __init__(self, telegramId, accountId, currentPeriodStart,                 currentPeriodEnd, isFreeTrial, isCanceled, canceledAt, isPaid):        self.accountId = accountId        self.telegramId = telegramId        self.currentPeriodStart = currentPeriodStart        self.currentPeriodEnd = currentPeriodEnd        self.isPaid = isPaid        self.isCanceled = isCanceled        self.canceledAt = canceledAt        self.isFreeTrial = isFreeTrial        super().__init__()    async def save(self):        async with AsyncSessionLocal() as session:            session.add(self)            await session.commit()        return self    @classmethod    async def get(cls, subscriptionId):        async with AsyncSessionLocal() as session:            subscription = await session.execute(select(AccountSubscription)                                          .filter(AccountSubscription.id == subscriptionId))            subscription = subscription.scalar_one_or_none()            return subscription    @classmethod    async def getByAccountId(cls, accountId):        async with AsyncSessionLocal() as session:            subscription = await session.execute(select(AccountSubscription)                                                 .filter(AccountSubscription.accountId == accountId))            subscription = subscription.scalar_one_or_none()            return subscription    @classmethod    async def update(cls, instance, column, value):        async with AsyncSessionLocal() as session:            setattr(instance, column, value)            await session.commit()    @classmethod    async def delete(cls, subscriptionId):        async with AsyncSessionLocal() as session:            subscription = await session.execute(select(AccountSubscription).filter(AccountSubscription.id ==                                                                                    subscriptionId))            subscription = subscription.scalar_one_or_none()            if subscription:                session.delete(subscription)                await session.commit()    def to_dict(self):        """Converts SQL Alchemy model instance to dictionary."""        return {c.key: getattr(self, c.key) for c in class_mapper(self.__class__).mapped_table.c}